rules_version = '2';

service cloud.firestore {
  match /databases/{db}/documents {

    // =========================================================================
    // ARCHITECTURE NOTE
    // =========================================================================
    //
    // users, usernames, and spots are stored exclusively in PostgreSQL (Neon)
    // via Drizzle ORM. They do NOT exist as Firestore collections.
    //
    // Firestore is used only for real-time features:
    //   presence, chat_messages, game_sessions, notifications,
    //   active_checkins, challenge_votes, leaderboard_live,
    //   challenges, games, videos, products, holds, orders
    //
    // Do NOT add Firestore rules for users, usernames, or spots.
    //
    // =========================================================================

    // =========================================================================
    // HELPER FUNCTIONS
    // =========================================================================

    function isAuthenticated() {
      return request.auth != null;
    }

    function isOwner(userId) {
      return isAuthenticated() && request.auth.uid == userId;
    }

    function hasRequiredFields(fields) {
      return request.resource.data.keys().hasAll(fields);
    }

    function isValidString(field, minLen, maxLen) {
      return request.resource.data[field] is string
        && request.resource.data[field].size() >= minLen
        && request.resource.data[field].size() <= maxLen;
    }

    // Timestamp must be recent (within last 5 minutes, and not too far in future)
    function isRecentTimestamp(field) {
      return request.resource.data[field] is timestamp
        && request.resource.data[field] >= request.time - duration.value(5, 'm')
        && request.resource.data[field] <= request.time + duration.value(1, 'm');
    }

    function isGameParticipant(gameData) {
      return isAuthenticated()
        && (gameData.player1Id == request.auth.uid || gameData.player2Id == request.auth.uid);
    }

    // =========================================================================
    // ENVIRONMENT NAMESPACED DATA
    // Real-time Firestore collections may use /env/{environment}/ prefix for
    // prod/staging isolation.
    //
    // IMPORTANT:
    // - 'local' is NOT allowed in production Firestore.
    // - Local development should use Firebase Emulator.
    //
    // NOTE:
    // Without custom claims, server-side enforcement of environment isolation is
    // limited. Client guardrails should enforce correct env usage.
    // =========================================================================

    // Staging environment: read-only for authenticated users.
    // Writes are handled by explicit collection rules or via Admin SDK on the server.
    match /env/staging/{path=**} {
      allow read: if isAuthenticated();
      allow write: if false;
    }

    // Production environment: read allowed for authenticated users.
    // Client writes are only allowed for explicitly listed collections below.
    // Everything else (billing, admin, moderation, analytics_events, etc.) is
    // server-only via Admin SDK.
    match /env/prod/{collection}/{docId=**} {
      allow read: if isAuthenticated();
      allow write: if false;
    }

    // =========================================================================
    // MODERATION (server-only via Admin SDK)
    // =========================================================================

    match /moderation_users/{userId} {
      allow read: if isAuthenticated() && request.auth.uid == userId;
      allow write: if false;
    }

    match /reports/{reportId} {
      allow read, write: if false;
    }

    match /mod_actions/{actionId} {
      allow read, write: if false;
    }

    match /moderation_quotas/{quotaId} {
      allow read, write: if false;
    }

    // =========================================================================
    // USERS - /users/{userId}
    //
    // This is NOT the authoritative user record.
    // Authoritative data (email, profile, username, spots) is in PostgreSQL.
    //
    // What's written here:
    //   - Client creates on sign-up: { uid, displayName, createdAt, updatedAt }
    //     (see authStore.ts signUpWithEmail)
    //   - Server Cloud Function updates roles via Admin SDK (bypasses these rules)
    //   - Server may write xp/isPro via Admin SDK (bypasses these rules)
    //
    // What clients read: isPro, role, xp for display badges (see user.ts store)
    //
    // NOT here: email, password, username, bio, spot history â€” PostgreSQL only.
    // =========================================================================

    match /users/{userId} {
      allow read: if isAuthenticated();

      // Client creates minimal display doc on sign-up.
      // Strictly limited to what authStore.ts actually writes.
      allow create: if isOwner(userId)
        && request.resource.data.keys().hasOnly(['uid', 'displayName', 'createdAt', 'updatedAt'])
        && request.resource.data.uid == request.auth.uid
        && request.resource.data.createdAt is timestamp
        && request.resource.data.updatedAt is timestamp;

      // Updates (roles, xp, isPro) go through the server via Admin SDK only.
      allow update, delete: if false;
    }

    // =========================================================================
    // USER PRESENCE
    // =========================================================================

    match /presence/{userId} {
      allow read: if isAuthenticated();

      allow write: if isOwner(userId)
        && hasRequiredFields(['status', 'lastSeen'])
        && request.resource.data.status in ['online', 'offline', 'away']
        && request.resource.data.lastSeen is timestamp
        && request.resource.data.lastSeen >= request.time - duration.value(1, 'm')
        && request.resource.data.lastSeen <= request.time + duration.value(1, 'm')
        // Prevent arbitrary data injection
        && request.resource.data.keys().hasOnly(['status', 'lastSeen', 'deviceId']);
    }

    // =========================================================================
    // CHAT MESSAGES (AI Skate Buddy)
    // =========================================================================

    match /chat_messages/{messageId} {
      allow read: if isAuthenticated()
        && resource.data.userId == request.auth.uid;

      allow create: if isAuthenticated()
        && request.resource.data.userId == request.auth.uid
        && hasRequiredFields(['userId', 'message', 'role', 'createdAt'])
        && isValidString('message', 1, 5000)
        && request.resource.data.role == 'user'
        && isRecentTimestamp('createdAt')
        && messageId.matches('^' + request.auth.uid + '_.*');

      allow update: if isOwner(resource.data.userId)
        && resource.data.role == 'user'
        && request.resource.data.userId == resource.data.userId
        && request.resource.data.role == resource.data.role
        && request.resource.data.createdAt == resource.data.createdAt
        && isValidString('message', 1, 5000)
        && (!('updatedAt' in request.resource.data) || request.resource.data.updatedAt is timestamp);

      allow delete: if isOwner(resource.data.userId) && resource.data.role == 'user';
    }

    // =========================================================================
    // GAME SESSIONS (Real-time SKATE)
    // All mutations go through Cloud Functions (submitTrick, judgeTrick,
    // processVoteTimeouts) which use Admin SDK. Direct client writes are
    // blocked to prevent bypassing server-side validation and race condition
    // protections. See docs/RACE_CONDITIONS.md for details.
    // =========================================================================

    match /game_sessions/{gameId} {
      allow read: if isAuthenticated()
        && (resource.data.player1Id == request.auth.uid
            || resource.data.player2Id == request.auth.uid);

      allow create, update, delete: if false;
    }

    // =========================================================================
    // NOTIFICATIONS
    // =========================================================================

    match /notifications/{notificationId} {
      allow read: if isAuthenticated()
        && resource.data.userId == request.auth.uid;

      allow create: if false;

      allow update: if isOwner(resource.data.userId)
        && request.resource.data.userId == resource.data.userId
        && request.resource.data.createdAt == resource.data.createdAt
        && request.resource.data.diff(resource.data).affectedKeys().hasOnly(['read', 'readAt'])
        && request.resource.data.read is bool
        && (!('readAt' in request.resource.data) || request.resource.data.readAt is timestamp);

      allow delete: if isOwner(resource.data.userId);
    }

    // =========================================================================
    // ACTIVE CHECK-INS
    // =========================================================================

    match /active_checkins/{checkinId} {
      allow read: if isAuthenticated();

      allow create: if isAuthenticated()
        && hasRequiredFields(['userId', 'spotId', 'checkedInAt'])
        && request.resource.data.userId == request.auth.uid
        && isValidString('spotId', 1, 100)
        && isRecentTimestamp('checkedInAt')
        && checkinId == request.auth.uid + '_' + request.resource.data.spotId
        && (!('latitude' in request.resource.data) || request.resource.data.latitude is number)
        && (!('longitude' in request.resource.data) || request.resource.data.longitude is number)
        && (!('displayName' in request.resource.data) || isValidString('displayName', 1, 50));

      allow update: if isOwner(resource.data.userId)
        && request.resource.data.userId == resource.data.userId
        && request.resource.data.spotId == resource.data.spotId
        && request.resource.data.checkedInAt == resource.data.checkedInAt
        && (!('checkedOutAt' in request.resource.data) || request.resource.data.checkedOutAt is timestamp);

      allow delete: if isOwner(resource.data.userId);
    }

    // =========================================================================
    // CHALLENGE VOTES
    // =========================================================================

    match /challenge_votes/{voteId} {
      allow read: if isAuthenticated();

      allow create: if isAuthenticated()
        && hasRequiredFields(['userId', 'challengeId', 'submissionId', 'voteType', 'createdAt'])
        && request.resource.data.userId == request.auth.uid
        && isValidString('challengeId', 1, 100)
        && isValidString('submissionId', 1, 100)
        && request.resource.data.voteType in ['upvote', 'downvote']
        && isRecentTimestamp('createdAt')
        && voteId == request.auth.uid + '_' + request.resource.data.submissionId;

      allow update: if isOwner(resource.data.userId)
        && request.resource.data.userId == resource.data.userId
        && request.resource.data.challengeId == resource.data.challengeId
        && request.resource.data.submissionId == resource.data.submissionId
        && request.resource.data.createdAt == resource.data.createdAt
        && request.resource.data.voteType in ['upvote', 'downvote']
        && request.resource.data.voteType != resource.data.voteType
        && (!('updatedAt' in request.resource.data) || request.resource.data.updatedAt is timestamp);

      allow delete: if isOwner(resource.data.userId);
    }

    // =========================================================================
    // LIVE LEADERBOARD (server-written)
    // =========================================================================

    match /leaderboard_live/{userId} {
      allow read: if isAuthenticated();
      allow create, update, delete: if false;
    }

    // =========================================================================
    // LEGACY COLLECTIONS
    // =========================================================================

    // Enhanced signup security (unauth allowed)
    match /signups/{doc} {
      allow create: if
        // Email validation
        request.resource.data.email is string
        && request.resource.data.email.size() > 3
        && request.resource.data.email.size() < 254
        && request.resource.data.email.matches('^[^@\\s]+@[^@\\s]+\\.[^@\\s]+$')

        // Source validation
        && request.resource.data.source in ['site', 'app', 'landing']

        // Timestamp validation
        && request.resource.data.createdAt == request.time

        // Honeypot validation
        && (!('company' in request.resource.data) || request.resource.data.company == '')

        // Strict field allowlist
        && request.resource.data.keys().hasOnly(['email', 'source', 'createdAt', 'userAgent', 'timestamp'])

        && (!('userAgent' in request.resource.data) || request.resource.data.userAgent is string)
        && (!('timestamp' in request.resource.data) || request.resource.data.timestamp is number)

        // Rate limiting (only enforce if authenticated; avoid null auth crashes)
        && (
          !isAuthenticated()
          || !exists(/databases/$(db)/documents/signups/$(request.auth.uid))
          || get(/databases/$(db)/documents/signups/$(request.auth.uid)).data.createdAt < request.time - duration.value(1, 'm')
        );

      allow read, update, delete: if false;
    }

    match /mail/{doc} {
      allow read, write: if false;
    }

    match /mail_list/{docId} {
      allow read, write: if false;
    }

    match /subscriptions/{document} {
      allow read, write: if false;
    }

    // =========================================================================
    // REMOTE S.K.A.T.E. CHALLENGES
    // =========================================================================

    match /challenges/{challengeId} {
      allow read: if isAuthenticated()
        && (resource.data.createdBy == request.auth.uid
            || resource.data.opponent == request.auth.uid
            || request.auth.uid in resource.data.participants);

      allow create: if isAuthenticated()
        && hasRequiredFields(['createdBy', 'opponent', 'participants', 'rules', 'status', 'createdAt'])
        && request.resource.data.createdBy == request.auth.uid
        && request.resource.data.opponent != request.auth.uid
        && request.resource.data.participants.size() == 2
        && request.auth.uid in request.resource.data.participants
        && request.resource.data.opponent in request.resource.data.participants

        && request.resource.data.rules.oneTake == true
        && request.resource.data.rules.durationSec == 15

        && request.resource.data.clipA.createdBy == request.auth.uid
        && request.resource.data.clipA.durationSec >= 14.5
        && request.resource.data.clipA.durationSec <= 15.5
        && request.resource.data.clipA.url is string
        && request.resource.data.clipA.url.size() >= 1
        && request.resource.data.clipA.url.size() <= 2000

        && request.resource.data.status == 'pending'
        && isRecentTimestamp('createdAt');

      allow update: if isAuthenticated()
        && (
          (resource.data.opponent == request.auth.uid
           && resource.data.status == 'pending'
           && request.resource.data.status == 'active'
           && 'clipB' in request.resource.data
           && request.resource.data.clipB.createdBy == request.auth.uid
           && request.resource.data.clipB.durationSec >= 14.5
           && request.resource.data.clipB.durationSec <= 15.5
           && request.resource.data.clipB.url is string
           && request.resource.data.clipB.url.size() >= 1
           && request.resource.data.clipB.url.size() <= 2000)
          ||
          (resource.data.createdBy == request.auth.uid
           && resource.data.status == 'pending'
           && request.resource.data.status == 'cancelled')
        )
        && request.resource.data.createdBy == resource.data.createdBy
        && request.resource.data.opponent == resource.data.opponent
        && request.resource.data.participants == resource.data.participants
        && request.resource.data.rules == resource.data.rules
        && request.resource.data.createdAt == resource.data.createdAt
        && request.resource.data.clipA == resource.data.clipA;

      allow delete: if isAuthenticated()
        && resource.data.createdBy == request.auth.uid
        && resource.data.status == 'pending';
    }

    // =========================================================================
    // REMOTE S.K.A.T.E. - Video-verified games
    // =========================================================================

    // Helper: check if user is a participant in a remote SKATE game
    function isRemoteGameParticipant(gameData) {
      return isAuthenticated()
        && (gameData.playerAUid == request.auth.uid
            || gameData.playerBUid == request.auth.uid);
    }

    // Games collection
    match /games/{gameId} {
      // Only participants can read
      allow read: if isAuthenticated()
        && (resource.data.playerAUid == request.auth.uid
            || resource.data.playerBUid == request.auth.uid);

      // Creator can create (playerA = self, playerB = null, status = waiting)
      allow create: if isAuthenticated()
        && request.resource.data.createdByUid == request.auth.uid
        && request.resource.data.playerAUid == request.auth.uid
        && request.resource.data.playerBUid == null
        && request.resource.data.status == 'waiting';

      // Participants can update (join, turn changes, cancel)
      // Resolution and letter changes are server-trusted via Admin SDK
      allow update: if isAuthenticated()
        && (
          // Player B joining a waiting game
          (resource.data.status == 'waiting'
           && resource.data.playerBUid == null
           && request.auth.uid != resource.data.playerAUid
           && request.resource.data.playerBUid == request.auth.uid
           && request.resource.data.status == 'active'
           && request.resource.data.playerAUid == resource.data.playerAUid
           && request.resource.data.createdByUid == resource.data.createdByUid
           && request.resource.data.createdAt == resource.data.createdAt)
          ||
          // Current turn player updating turn/lastMoveAt (for set/reply completion)
          (resource.data.status == 'active'
           && isRemoteGameParticipant(resource.data)
           && request.resource.data.status == 'active'
           && request.resource.data.playerAUid == resource.data.playerAUid
           && request.resource.data.playerBUid == resource.data.playerBUid
           && request.resource.data.createdByUid == resource.data.createdByUid
           && request.resource.data.createdAt == resource.data.createdAt)
          ||
          // Creator cancelling their own waiting game
          (resource.data.status == 'waiting'
           && resource.data.playerAUid == request.auth.uid
           && request.resource.data.status == 'cancelled'
           && request.resource.data.playerAUid == resource.data.playerAUid
           && request.resource.data.playerBUid == resource.data.playerBUid
           && request.resource.data.createdByUid == resource.data.createdByUid
           && request.resource.data.createdAt == resource.data.createdAt
           && request.resource.data.letters == resource.data.letters
           && request.resource.data.currentTurnUid == resource.data.currentTurnUid)
        );

      allow delete: if false;

      // Rounds subcollection
      match /rounds/{roundId} {
        // Participants can read rounds
        allow read: if isAuthenticated()
          && (get(/databases/$(db)/documents/games/$(gameId)).data.playerAUid == request.auth.uid
              || get(/databases/$(db)/documents/games/$(gameId)).data.playerBUid == request.auth.uid);

        // Participants can create rounds (first round on join)
        allow create: if isAuthenticated()
          && (get(/databases/$(db)/documents/games/$(gameId)).data.playerAUid == request.auth.uid
              || get(/databases/$(db)/documents/games/$(gameId)).data.playerBUid == request.auth.uid)
          && request.resource.data.status == 'awaiting_set';

        // Participants can update rounds (set video ID, reply video ID, status transitions)
        // Resolution (status=resolved, result) is server-only via Admin SDK
        allow update: if isAuthenticated()
          && (get(/databases/$(db)/documents/games/$(gameId)).data.playerAUid == request.auth.uid
              || get(/databases/$(db)/documents/games/$(gameId)).data.playerBUid == request.auth.uid)
          && request.resource.data.offenseUid == resource.data.offenseUid
          && request.resource.data.defenseUid == resource.data.defenseUid
          && request.resource.data.createdAt == resource.data.createdAt
          // Cannot set result or resolved status from client
          && (request.resource.data.status == 'awaiting_set'
              || request.resource.data.status == 'awaiting_reply');

        allow delete: if false;
      }
    }

    // Videos collection
    match /videos/{videoId} {
      // Only creator can read their own video docs
      // Game participants can read via the video's gameId
      allow read: if isAuthenticated()
        && (resource.data.uid == request.auth.uid
            || (get(/databases/$(db)/documents/games/$(resource.data.gameId)).data.playerAUid == request.auth.uid
                || get(/databases/$(db)/documents/games/$(resource.data.gameId)).data.playerBUid == request.auth.uid));

      // Only creator can create video docs (uid must match auth)
      allow create: if isAuthenticated()
        && request.resource.data.uid == request.auth.uid
        && request.resource.data.status == 'uploading';

      // Only creator can update their video doc
      allow update: if isAuthenticated()
        && resource.data.uid == request.auth.uid
        && request.resource.data.uid == resource.data.uid
        && request.resource.data.gameId == resource.data.gameId
        && request.resource.data.roundId == resource.data.roundId;

      allow delete: if false;
    }

    // =========================================================================
    // COMMERCE - Products, Orders, Holds
    // =========================================================================

    // Products - publicly readable, admin write only
    match /products/{productId} {
      allow read: if true;
      allow write: if isAuthenticated() && request.auth.token.admin == true;

      // Stock shards - server only (managed by Cloud Functions)
      match /stockShards/{shardId} {
        allow read, write: if false;
      }
    }

    // Holds - owner can read, server manages writes
    match /holds/{holdId} {
      allow read: if isAuthenticated() && resource.data.uid == request.auth.uid;
      allow write: if false;
    }

    // Orders - owner can read, server manages writes
    match /orders/{orderId} {
      allow read: if isAuthenticated() && resource.data.uid == request.auth.uid;
      allow write: if false;
    }

    // Processed webhook events - server only
    match /processedEvents/{eventId} {
      allow read, write: if false;
    }

    // =========================================================================
    // DEFAULT DENY
    // =========================================================================

    match /{document=**} {
      allow read, write: if false;
    }
  }
}
